<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>面试复盘</title>
      <link href="/2023/09/05/%E9%9D%A2%E8%AF%95%E5%A4%8D%E7%9B%98/"/>
      <url>/2023/09/05/%E9%9D%A2%E8%AF%95%E5%A4%8D%E7%9B%98/</url>
      
        <content type="html"><![CDATA[<h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><h4 id="多线程用过吗？"><a href="#多线程用过吗？" class="headerlink" title="多线程用过吗？"></a>多线程用过吗？</h4><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">我知道的有三种: 第一种是继承 Thread 类，第二种就是实现 Runnable 接口,这样的好处是解决的 Java 类里不能多继承的问题,第三种是实现 Callable 接口。实现 Callable 接口，重写 call()方法</span><br></pre></td></tr></table></figure><h4 id="线程有哪几种状态"><a href="#线程有哪几种状态" class="headerlink" title="线程有哪几种状态"></a>线程有哪几种状态</h4><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">其实线程一般具有六种状态，即新建、正在运行、计时等待、永久等待，阻塞、终止。 </span><br><span class="line">新建状态 </span><br><span class="line">线程创建好 </span><br><span class="line">正在运行状态 </span><br><span class="line">调用了 start 方法状态 </span><br><span class="line">阻塞状态 </span><br><span class="line">加了同步锁的代码,多线程进行访问的时候,会有阻塞状态 </span><br><span class="line">无限等待状态 </span><br><span class="line">调用了 wait 方法,无限等待了,等待 notify 或者 notifyAll 方法进行唤醒 </span><br><span class="line">计时等待状态 </span><br><span class="line">自动唤醒,相当于使用了 sleep(1000) 或者 wait(传递时间)</span><br><span class="line">死亡(结束) </span><br><span class="line">不用结束线程,执行完 run 方法里的代码后,会自动结束线程</span><br></pre></td></tr></table></figure><h3 id="redis"><a href="#redis" class="headerlink" title="redis"></a>redis</h3><h4 id="redis自己部署过吗？"><a href="#redis自己部署过吗？" class="headerlink" title="redis自己部署过吗？"></a>redis自己部署过吗？</h4><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">项目中，我们一般都通过 springData 操作的 redis,他底层也是整合 redis 官方提供的 jedis工具包来操作 redis,我们开发的时候用的是单机版,项目上线用的是集群版本.</span><br></pre></td></tr></table></figure><h4 id="redis可以做持久化吗？"><a href="#redis可以做持久化吗？" class="headerlink" title="redis可以做持久化吗？"></a>redis可以做持久化吗？</h4><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">我们在项目的活动模块用过,APP 端的首页展示的数据都是使用 redis 存储的热点数据,因为用户进入 APP 的时候首先进入是首页,使用的hash 数据类型存储首页信息,特卖模块中也用过 redis,用它的 list 数据类型。</span><br></pre></td></tr></table></figure><h4 id="知道哨兵机制是怎么实现的吗？"><a href="#知道哨兵机制是怎么实现的吗？" class="headerlink" title="知道哨兵机制是怎么实现的吗？"></a>知道哨兵机制是怎么实现的吗？</h4><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">在主服务器宕机时，从服务器可以自动转换为主服务器。我们公司搭建的redis 集群是用的 ruby 脚本配合搭建的,我们一共搭建了 6 台服务器,3主3备，他们之间通信的原理是有一个乒乓协议进行通信的，他们判断一个节点的状态是用投票选举机制判断的, 半数以上判断一个接口是宕机了的话,备用节点就会启动。</span><br></pre></td></tr></table></figure><h4 id="原生态的redis用过吗？"><a href="#原生态的redis用过吗？" class="headerlink" title="原生态的redis用过吗？"></a>原生态的redis用过吗？</h4><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">原生态Redis是指在没有任何修改或补丁的情况下直接使用Redis。这意味着您使用的是Redis官方发布的原始版本，没有任何额外的功能或改动。</span><br><span class="line"></span><br><span class="line">原生态Redis提供了一系列的数据结构和功能，包括字符串、列表、哈希表、集合等，以及各种操作和命令来操作这些数据。它是一个快速、高效且可靠的键值存储系统，广泛用于缓存、消息队列、实时分析等应用场景。</span><br><span class="line"></span><br><span class="line">原生态Redis的优势在于它的稳定性和性能。因为没有进行过任何修改或补丁，所有的更新和维护都由Redis官方团队负责，可以保证系统的稳定性和安全性。同时，Redis本身就是一个高性能、低延迟的数据库，可以处理大量的读写请求。</span><br><span class="line"></span><br><span class="line">原生态Redis的劣势在于它的功能相对有限。相比一些经过修改和定制的Redis版本，原生态Redis可能缺乏一些特定领域或应用场景的定制功能。但是，对于大多数普通的应用来说，原生态Redis提供的功能已经足够满足需求。</span><br><span class="line"></span><br><span class="line">总而言之，原生态Redis是一个稳定、高效的键值存储系统，适用于大多数应用场景。它的简洁和纯净使得它易于部署和维护，并且具有较少的潜在问题和风险。</span><br></pre></td></tr></table></figure><h4 id="redis常用功能说一下？"><a href="#redis常用功能说一下？" class="headerlink" title="redis常用功能说一下？"></a>redis常用功能说一下？</h4><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">1：哨兵(sentinel)和复制（replication）</span><br><span class="line">哨兵可以管理多个redis服务器，提供监控、提醒以及自动的故障转移的功能。replication 负责让一个redis服务器可以配备多个备份的服务器,redis就是利用这2个功能来保证redis的高可用的。</span><br><span class="line">2：事务</span><br><span class="line">一次性执行多个命令，保证原子性</span><br><span class="line">3：LUA脚本</span><br><span class="line">在事务的基础上，如果我们需要在服务器一次性执行更复杂的操作，lua就可以用上了。</span><br><span class="line">4：持久化</span><br><span class="line">redis会把内存中的数据写入硬盘中，在redis重启的时候加载这些数据，最大限度的降低缓存丢失带来的影响。</span><br><span class="line">5:集群(cluster)</span><br><span class="line">单台服务器的资源总是有上线的，cpu资源和IO资源可以通过主从复制，进行读写分离，把一部分cpu和io的压力转移到从服务器上，类似mysql的主从同步。</span><br></pre></td></tr></table></figure><h4 id="Redis用的是什么模式？"><a href="#Redis用的是什么模式？" class="headerlink" title="Redis用的是什么模式？"></a>Redis用的是什么模式？</h4><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">1. 缓存模式：将频繁访问的数据存储在Redis中，以加速读取操作。这是Redis最常见的用法之一，通过在内存中存储数据，可以减轻数据库的负载，提高系统的响应速度。</span><br><span class="line"></span><br><span class="line">2. 分布式缓存模式：使用Redis集群来构建分布式缓存系统，将数据分散存储在多个节点上，以增加缓存容量和可用性。</span><br><span class="line"></span><br><span class="line">3. 发布订阅模式：通过Redis的发布-订阅机制，可以实现消息发布和订阅功能。发布者将消息发布到指定的频道，订阅者可以订阅感兴趣的频道来接收消息。</span><br><span class="line"></span><br><span class="line">4. 计数器模式：使用Redis的原子性操作，可以实现各种计数器功能，如网站访问次数统计、点赞数量统计等。</span><br><span class="line"></span><br><span class="line">5. 排行榜模式：通过有序集合（Sorted Set）数据结构，可以实现排行榜功能，例如排行榜、热门内容列表等。</span><br><span class="line"></span><br><span class="line">6. 会话存储模式：将用户会话信息存储在Redis中，以支持无状态的Web应用，从而实现负载均衡和高可用性。</span><br><span class="line"></span><br><span class="line">7. 分布式锁模式：使用Redis的分布式锁功能，可以解决多个节点间的并发控制问题，确保在分布式环境下的数据一致性。</span><br><span class="line"></span><br><span class="line">8. 持久化存储模式：Redis支持将数据持久化到磁盘，以便在重启后恢复数据。可以选择使用快照（Snapshotting）或Append-only文件（AOF）方式进行持久化。</span><br><span class="line"></span><br><span class="line">9. Geo数据模式：使用Redis的Geo数据类型，可以实现地理位置相关的操作，如查找附近的位置、计算距离等。</span><br><span class="line"></span><br><span class="line">10. Bitmap模式：使用位图数据类型，可以进行一些位操作，如统计在线用户、标记用户活跃状态等。</span><br></pre></td></tr></table></figure><h4 id="Redis集群模式的优势？"><a href="#Redis集群模式的优势？" class="headerlink" title="Redis集群模式的优势？"></a>Redis集群模式的优势？</h4><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">1. 横向扩展： Redis集群允许在多个节点上分布数据，实现了横向扩展。这使得集群可以处理更大的数据负载和并发请求，从而满足高流量的应用需求。</span><br><span class="line"></span><br><span class="line">2. 高可用性： 集群模式通过数据分片和复制来提供高可用性。每个分片可以有多个副本（节点），当主节点不可用时，集群可以自动进行故障切换，提供持续的服务。</span><br><span class="line"></span><br><span class="line">3. 数据均衡： Redis集群自动将数据分布到不同的节点上，以实现负载均衡。这可以避免出现某些节点负载过重，而其他节点闲置的情况。</span><br><span class="line"></span><br><span class="line">4. 分区容错： 集群模式可以在某些节点出现故障或失效的情况下继续正常运行，只影响到受影响的分片，而不会导致整个集群的不可用。</span><br><span class="line"></span><br><span class="line">5. 动态扩展： 您可以根据需要随时添加新的节点来扩展集群的容量和性能，而不需要停止服务。新节点会自动参与到集群中，进行数据迁移和分片重新分配。</span><br><span class="line"></span><br><span class="line">6. 水平分片： 集群模式允许将数据分布在多个分片上，从而实现水平分片。这对于需要大量存储空间或高并发性能的应用非常有用。</span><br><span class="line"></span><br><span class="line">7. Failover： 当主节点不可用时，集群会自动选举一个新的主节点，确保服务的连续性。同时，集群会自动将副本提升为主节点，以保持高可用性。</span><br><span class="line"></span><br><span class="line">8. 无单点故障： Redis集群没有单点故障，因为数据分布在多个节点上。即使某个节点出现故障，集群仍然可以继续提供服务。</span><br></pre></td></tr></table></figure><h4 id="Redis中的key是怎么寻址的？"><a href="#Redis中的key是怎么寻址的？" class="headerlink" title="Redis中的key是怎么寻址的？"></a>Redis中的key是怎么寻址的？</h4><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">具体的寻址过程如下：</span><br><span class="line"></span><br><span class="line">1. 将所有的服务器节点映射到一个虚拟的哈希环上，通常通过计算节点的哈希值来确定其在环上的位置。</span><br><span class="line"></span><br><span class="line">2. 当需要处理或获取某个key时，首先计算该key的哈希值。</span><br><span class="line"></span><br><span class="line">3. 然后在哈希环上顺时针方向寻找离该key哈希值最近的节点。这个节点就被选为处理或存储该key的节点。</span><br><span class="line"></span><br><span class="line">这种一致性哈希算法具有以下优势：</span><br><span class="line"></span><br><span class="line">- 增加或删除节点时，只需要对受影响的部分进行重新映射，而不会影响到整个集群的数据分布。</span><br><span class="line">- 当某个节点故障时，只会影响到部分数据，而不会影响到整个集群。</span><br><span class="line">- 数据在节点间的分布相对均匀，避免了单一节点负载过重的问题。</span><br></pre></td></tr></table></figure><h4 id="Redis的内部是怎么做数据存储的？"><a href="#Redis的内部是怎么做数据存储的？" class="headerlink" title="Redis的内部是怎么做数据存储的？"></a>Redis的内部是怎么做数据存储的？</h4><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">1. 字符串（String）： Redis中的字符串是最基本的数据结构，用于存储任意二进制数据。每个字符串都有一个键作为唯一标识。</span><br><span class="line"></span><br><span class="line">2. 哈希表（Hash）： 哈希表用于存储字段-值对，类似于关联数组或字典。哈希表适用于存储对象的多个属性，每个属性都有一个键和一个值。</span><br><span class="line"></span><br><span class="line">3. 列表（List）： 列表是有序的字符串列表，支持在头部和尾部进行插入和删除操作。列表适用于实现消息队列、最新消息列表等场景。</span><br><span class="line"></span><br><span class="line">4. 集合（Set）： 集合是无序的字符串集合，支持对成员的添加、删除和判断成员是否存在。集合适用于实现唯一性的存储，例如粉丝列表、点赞用户等。</span><br><span class="line"></span><br><span class="line">5. 有序集合（Sorted Set）： 有序集合是一种有序的集合，每个成员都有一个分数值，根据分数值进行排序。适用于排行榜、热门内容列表等场景。</span><br><span class="line"></span><br><span class="line">6. Bitmap： Redis内部可以使用Bitmap数据结构来存储位数据，适用于一些特定的位操作，如统计在线用户、标记用户活跃状态等。</span><br><span class="line"></span><br><span class="line">7. HyperLogLog： 用于近似统计的数据结构，可以在高效的内存使用下估计集合的基数（不重复元素的数量）。</span><br><span class="line"></span><br><span class="line">8. 地理位置数据（Geo）： 用于存储地理位置信息和坐标，支持位置查询和计算两点之间的距离。</span><br></pre></td></tr></table></figure><h4 id="Redis中的集群和哨兵模式的优缺点是什么？"><a href="#Redis中的集群和哨兵模式的优缺点是什么？" class="headerlink" title="Redis中的集群和哨兵模式的优缺点是什么？"></a>Redis中的集群和哨兵模式的优缺点是什么？</h4><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">Redis集群模式：</span><br><span class="line"></span><br><span class="line">优点：</span><br><span class="line"></span><br><span class="line">1. 横向扩展： 集群模式支持横向扩展，可以将数据分布在多个节点上，以处理更大的数据量和更高的并发请求。</span><br><span class="line"></span><br><span class="line">2. 高可用性： 集群模式通过数据分片和节点复制来实现高可用性。每个分片可以有多个副本，当主节点不可用时，自动进行故障切换。</span><br><span class="line"></span><br><span class="line">3. 负载均衡： 集群模式自动将数据均匀地分布到不同的节点上，实现负载均衡，避免某些节点负载过重。</span><br><span class="line"></span><br><span class="line">4. 动态扩展： 可以随时添加新的节点来扩展集群的容量和性能，无需停止服务，新节点会自动参与到集群中。</span><br><span class="line"></span><br><span class="line">缺点：</span><br><span class="line"></span><br><span class="line">1. 复杂性： 部署和维护一个Redis集群相对复杂，需要管理多个节点、数据分片和复制，配置也相对繁琐。</span><br><span class="line"></span><br><span class="line">2. 一致性保证： 集群模式不能保证严格的一致性，可能会出现数据分片导致数据不一致的情况。</span><br><span class="line"></span><br><span class="line">Redis哨兵模式：</span><br><span class="line"></span><br><span class="line">优点：</span><br><span class="line"></span><br><span class="line">1. 简单性： 哨兵模式相对于集群模式来说部署和维护相对简单，只需要少数几个哨兵节点来监控主节点和副本节点的状态。</span><br><span class="line"></span><br><span class="line">2. 高可用性： 哨兵模式可以在主节点不可用时自动切换到备用副本节点，确保服务的持续可用性。</span><br><span class="line"></span><br><span class="line">3. 动态监控： 哨兵会定期监控节点的状态，一旦节点出现故障，会自动触发故障切换操作。</span><br><span class="line"></span><br><span class="line">缺点：</span><br><span class="line"></span><br><span class="line">1. 单点故障： 哨兵模式中的哨兵节点本身可能成为单点故障，如果哨兵节点不可用，可能会影响到整个故障切换过程。</span><br><span class="line"></span><br><span class="line">2. 不支持分片： 哨兵模式不支持数据分片，因此对于大量数据的场景，可能需要结合其他方法来进行分片。</span><br></pre></td></tr></table></figure><h4 id="用过redis的分布式锁吗"><a href="#用过redis的分布式锁吗" class="headerlink" title="用过redis的分布式锁吗?"></a>用过redis的分布式锁吗?</h4><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">Redis的分布式锁是一种用于在分布式系统中实现并发控制的机制，以确保在多个节点同时访问共享资源时，只有一个节点能够成功获取锁并执行操作。分布式锁可以用于防止并发更新、避免重复操作、保证数据一致性等场景。</span><br></pre></td></tr></table></figure><h4 id="redis的分布式锁用的那个命令？"><a href="#redis的分布式锁用的那个命令？" class="headerlink" title="redis的分布式锁用的那个命令？"></a>redis的分布式锁用的那个命令？</h4><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">在Redis中，实现基本的分布式锁通常使用的是`SET`命令，结合`NX`（当键不存在时设置成功）和`PX`（设置键的过期时间）参数。</span><br></pre></td></tr></table></figure><h4 id="RedisTemplate是怎么实现分布式锁的？"><a href="#RedisTemplate是怎么实现分布式锁的？" class="headerlink" title="RedisTemplate是怎么实现分布式锁的？"></a>RedisTemplate是怎么实现分布式锁的？</h4><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">执行Lua脚本来实现分布式锁。其中lockScript用于获取锁，unlockScript用于释放锁。这两个脚本都是原子操作，可以通过RedisTemplate的execute方法执行。</span><br></pre></td></tr></table></figure><h4 id="锁的看门狗机制？"><a href="#锁的看门狗机制？" class="headerlink" title="锁的看门狗机制？"></a>锁的看门狗机制？</h4><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">锁的看门狗机制（Lock Watchdog Mechanism）是一种用于确保分布式锁在获取锁的客户端异常情况下能够被正确释放的机制。在分布式环境中，获取锁后的客户端可能会因为各种原因（例如网络故障、进程崩溃等）导致没有机会显式地释放锁，从而导致死锁或长时间的锁占用。</span><br><span class="line"></span><br><span class="line">看门狗机制的基本思想是为每个获取的锁设置一个自动续租的定时任务（看门狗），以防止锁的持有者在意外情况下失去与锁的联系。如果锁的持有者因为某些原因失去了能够释放锁的机会，看门狗会定期延长锁的过期时间，确保锁不会无限期地被占用。</span><br><span class="line"></span><br><span class="line">在Redis中，可以通过以下方式来实现锁的看门狗机制：</span><br><span class="line"></span><br><span class="line">1. 获取锁时设置过期时间： 在获取锁时，通过`SET`命令设置锁键的过期时间，确保即使没有显式释放锁，锁也会在一定时间后自动过期。这是基础的锁超时机制。</span><br><span class="line"></span><br><span class="line">2. 开启看门狗定时任务： 在获取锁时，同时开启一个定时任务，定期检查锁是否还在持有者手中。如果锁的持有者无法正常续租（例如节点宕机），看门狗会尝试为锁续租。</span><br><span class="line"></span><br><span class="line">3. 续租锁的过期时间： 看门狗定时任务会定期使用`EXPIRE`命令为锁键设置新的过期时间，延长锁的生存期。这样即使持有锁的客户端异常退出，锁也会在一段时间后自动释放。</span><br></pre></td></tr></table></figure><h3 id="环境搭建和日志"><a href="#环境搭建和日志" class="headerlink" title="环境搭建和日志"></a>环境搭建和日志</h3><h4 id="项目环境的搭建有负责吗？"><a href="#项目环境的搭建有负责吗？" class="headerlink" title="项目环境的搭建有负责吗？"></a>项目环境的搭建有负责吗？</h4><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">我们原来公司都是测试人员自己搭建测试环境的，因为这样子的测试工作能比较自主独立的开展，而且后期的维护也会比较方便一些。我们一般会在拿到测试需求的时候，根据需求先把准备环境好。因为我上一家公司是一家防火墙公司，有自己的设备，也有相应的web应用和APP，所以我会同时测试这些前端应用以及防火墙设备服务。所以准备这样的测试环境，我们会需要准备两台Linux服务器分别模拟客户端和后端服务器，搭建好测试拓扑，配通网络就可以。然后Linux系统我们一般也会自己安装，而且还要准备好相应的服务。然后我们会用客户端模拟一些用户流量，也会在Windows上安装一些常用的测试工具来模拟用户数据来测试产品。这样最初的测试环境搭建基本就完成了。</span><br></pre></td></tr></table></figure><h4 id="日志分析和排查用的什么方法？"><a href="#日志分析和排查用的什么方法？" class="headerlink" title="日志分析和排查用的什么方法？"></a>日志分析和排查用的什么方法？</h4><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">查询日志关键词 grep 关键词 * 查询被占用端口号 lsof -i:端口号</span><br></pre></td></tr></table></figure><h4 id="你们日志写在哪里？"><a href="#你们日志写在哪里？" class="headerlink" title="你们日志写在哪里？"></a>你们日志写在哪里？</h4><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">代码日志处理我们使用的是 slf4j,有一个配置文件,可以配置 log 输出的位置和 log 的输出形式,我们对于整个项目，设置了一个全局异常，当出现异常信息的时候，将异常信息记录到log文件中,我们以前也用过AOP记录过用过的操作日志,这差不多就是我知道的日志这一块.日志等级分为 5 个阶段。</span><br><span class="line">1.DEBUG:详细的信息,通常只出现在诊断问题上 </span><br><span class="line">2.INFO:确认一切按预期运行 </span><br><span class="line">3.WARNING:一个迹象表明,一些意想不到的事情发生了,或表明一些问题在不久的将来(“例如。磁盘空间低”)。这个软件还能按预期工作。 </span><br><span class="line">4.ERROR:更严重的问题,软件没能执行一些功能 </span><br><span class="line">5.CRITICAL:一个严重的错误,这表明程序本身可能无法继续运行</span><br></pre></td></tr></table></figure><h3 id="linux"><a href="#linux" class="headerlink" title="linux"></a>linux</h3><h4 id="Linux经常使用的命令有哪些？"><a href="#Linux经常使用的命令有哪些？" class="headerlink" title="Linux经常使用的命令有哪些？"></a>Linux经常使用的命令有哪些？</h4><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">查询进程：ps aux|grep 进程名。</span><br><span class="line">杀死进程：kill -999 进程 id。</span><br><span class="line">复制命令：cp。</span><br><span class="line">剪切命令：mv。</span><br><span class="line">解压命令：tar -zvxf 压缩包, 授权命令 chmod 777 文件。</span><br></pre></td></tr></table></figure><h4 id="Linux查找文件的命令？"><a href="#Linux查找文件的命令？" class="headerlink" title="Linux查找文件的命令？"></a>Linux查找文件的命令？</h4><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">按文件名：find 路径 -name &quot;文件名&quot;</span><br><span class="line">按文件类型查询：find 路径 -type 类型</span><br><span class="line">然后用 sed 命令定位到某一行</span><br></pre></td></tr></table></figure><h4 id="怎么用命令跟踪日志？"><a href="#怎么用命令跟踪日志？" class="headerlink" title="怎么用命令跟踪日志？"></a>怎么用命令跟踪日志？</h4><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">tail命令 - 实时监控日志。</span><br><span class="line">multitail命令 - 实时监控多个日志文件。</span><br><span class="line">lnav命令 - 实时监控多个日志文件。</span><br><span class="line">less命令 - 显示日志文件的实时输出。</span><br></pre></td></tr></table></figure><h4 id="原生tomcat会配置吗？"><a href="#原生tomcat会配置吗？" class="headerlink" title="原生tomcat会配置吗？"></a>原生tomcat会配置吗？</h4><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">配置Web应用程序：在Tomcat的webapps目录下创建一个新的文件夹，这将是你的Web应用程序的根目录。将你的Web应用程序的WAR文件（或展开的WAR文件内容）放入这个文件夹。</span><br><span class="line"></span><br><span class="line">配置应用程序：根据你的应用程序需要，在webapps/your<span class="built_in">_</span>app目录下创建WEB-INF文件夹，并在其中放置一个web.xml文件（如果需要的话）以配置Servlet和其他Web应用程序组件。</span><br><span class="line"></span><br><span class="line">启动Tomcat：进入Tomcat的bin目录，运行启动脚本（例如，startup.sh或startup.bat）来启动Tomcat。</span><br></pre></td></tr></table></figure><h3 id="Nginx用的多不多？"><a href="#Nginx用的多不多？" class="headerlink" title="Nginx用的多不多？"></a>Nginx用的多不多？</h3><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">他就是一个反向代理服务器,其实它的优点就是内存占用少,并发访问能力强,我知道的新浪, 斗鱼,好这些大公司都使用这个技术,它底层实现是 c 语言实现的.我们主要用到 nginx 两大主要的功能吧,一个是反向代理,一个是负载均衡,</span><br><span class="line"></span><br><span class="line">反向代理： Nginx 可以作为反向代理服务器，将客户端请求转发给后端应用服务器。这种配置可以隐藏真实服务器的IP地址，提供负载均衡、缓存、SSL终止等功能。</span><br><span class="line"></span><br><span class="line">负载均衡： Nginx 可以在多台后端服务器之间分配客户端请求，从而实现负载均衡。这可以提高系统的可扩展性和稳定性。</span><br></pre></td></tr></table></figure><h3 id="mq"><a href="#mq" class="headerlink" title="mq"></a>mq</h3><p>mq用过吗？</p><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">（1）服务间异步通信</span><br><span class="line">（2）顺序消费</span><br><span class="line">（3）定时任务</span><br><span class="line">（4）流量削峰</span><br><span class="line">我们项目中在订单和支付中都使用过，减轻服务器压力,降低项目之间的耦合度(解耦),是做异步的.</span><br></pre></td></tr></table></figure><p>mq怎么用的</p><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">消息队列是一种在分布式系统中用于异步通信的工具。它可以帮助不同组件或模块之间解耦，并提供了一种可靠的方式来传递和处理消息，而无需直接依赖于彼此的可用性和状态。</span><br><span class="line"></span><br><span class="line">在项目中使用消息队列通常涉及以下几个主要步骤：</span><br><span class="line"></span><br><span class="line">1. 选择合适的消息队列系统： 根据项目的需求和技术栈，选择适合的消息队列系统，比如 RabbitMQ、Apache Kafka、ActiveMQ 等。</span><br><span class="line"></span><br><span class="line">2. 定义消息格式： 在项目中，您需要定义要传递的消息的格式。这可能包括消息的结构、内容和元数据。</span><br><span class="line"></span><br><span class="line">3. 消息生产者（Producer）： 在项目的某个组件中，您会有一个消息生产者，负责创建并发送消息到消息队列。这可以是一些事件的触发器，如用户注册、订单生成等。</span><br><span class="line"></span><br><span class="line">4. 消息消费者（Consumer）： 在项目中的另一个组件中，您会有一个或多个消息消费者，负责从消息队列中接收消息并处理它们。消费者可能会根据消息的内容执行不同的操作，比如更新数据库、触发通知等。</span><br><span class="line"></span><br><span class="line">5. 异步处理： 使用消息队列可以将任务从同步转变为异步。例如，如果一个操作可能需要较长的处理时间，您可以将其放入消息队列并让消费者来处理，而不阻塞主要的应用逻辑。</span><br><span class="line"></span><br><span class="line">6. 保证可靠性： 大多数消息队列系统提供了一些机制来确保消息传递的可靠性，如确认机制、持久化存储等。这有助于确保即使在出现故障的情况下，消息也不会丢失。</span><br><span class="line"></span><br><span class="line">7. 扩展性： 使用消息队列还可以提高系统的扩展性。您可以通过增加消费者来分散负载，处理更多的消息流量。</span><br><span class="line"></span><br><span class="line">8. 错误处理： 在消息消费过程中可能会发生错误。您需要考虑如何处理这些错误，例如将错误消息记录下来，重试失败的消息等。</span><br></pre></td></tr></table></figure><p>Mq怎么防止数据丢失的？</p><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">1. 持久化消息： 大多数消息队列系统提供将消息持久化到磁盘的选项。这意味着即使消息队列系统在处理消息时出现故障，消息也不会丢失。持久化通常包括将消息存储在磁盘上，以便在恢复后重新发送。</span><br><span class="line"></span><br><span class="line">2. 确认机制： 生产者在将消息发送到消息队列后，可以等待消息队列的确认响应，以确保消息已经被成功接收并存储。如果没有收到确认，生产者可以重新发送消息。</span><br><span class="line"></span><br><span class="line">3. 事务性操作： 一些消息队列系统支持事务性操作，允许您将消息发送和确认操作包装在事务中。如果事务成功提交，消息会被发送到队列中，否则会回滚。</span><br><span class="line"></span><br><span class="line">4. 消息重试和补偿： 如果消息队列系统返回了发送失败的响应，生产者可以选择进行消息重试。此外，您可以在消费者端实现补偿机制，确保在处理消息时不丢失数据。</span><br><span class="line"></span><br><span class="line">5. 确认机制和超时处理： 消费者在处理消息后应该发送确认，表示已成功处理。如果在一定时间内未收到确认，消息队列可以将消息重新发送给其他消费者或者进行超时处理。</span><br><span class="line"></span><br><span class="line">6. 备份和冷备份： 一些消息队列系统支持备份和冷备份机制，确保即使主节点出现故障，备份节点仍然可以恢复数据。</span><br><span class="line"></span><br><span class="line">7. 消息轨迹和监控： 使用消息轨迹和监控工具，您可以跟踪消息在整个系统中的流动和状态，从而更好地理解消息丢失的原因。</span><br><span class="line"></span><br><span class="line">8. 持续监控和自动化处理： 建立监控系统，实时监测消息队列系统的状态和性能，及时发现并处理潜在的问题。</span><br></pre></td></tr></table></figure><h3 id="es"><a href="#es" class="headerlink" title="es"></a>es</h3><p>ES是怎么加索引的？</p><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">1. 创建索引： 在Elasticsearch中，索引是数据存储和搜索的逻辑单元，类似于关系型数据库中的表。要添加数据，首先需要创建一个索引。可以使用Elasticsearch的REST API或客户端库来创建索引。创建索引时，您需要定义索引的名称、字段映射等信息。</span><br><span class="line"></span><br><span class="line">2. 定义映射： 索引中的数据存储在文档中，每个文档都有一组字段。在添加索引之前，通常需要定义文档的映射，即指定文档中的字段类型、分析器等信息。映射的定义可以通过索引创建请求的`mappings`部分进行设置。</span><br><span class="line"></span><br><span class="line">3. 添加文档： 一旦索引和映射定义好，就可以向索引中添加文档了。文档是实际存储的数据单元，可以是JSON格式的数据。您可以通过Elasticsearch的API将文档添加到索引中。</span><br><span class="line"></span><br><span class="line">4. 搜索和查询： 添加文档后，可以使用Elasticsearch的查询语言来执行各种搜索和分析操作。通过指定查询条件、过滤条件等，可以从索引中检索出符合条件的文档。</span><br><span class="line"></span><br><span class="line">总结来说，将数据添加到Elasticsearch的索引中涉及以下步骤：</span><br><span class="line"></span><br><span class="line">1. 创建索引：定义索引的名称、设置、分片和副本等参数。</span><br><span class="line">2. 定义映射：指定每个字段的数据类型、分析器等信息。</span><br><span class="line">3. 添加文档：将实际数据以JSON格式添加到索引中。</span><br><span class="line">4. 执行搜索和查询：使用查询语言从索引中检索数据。</span><br></pre></td></tr></table></figure><p>怎么把数据库查出来的数据存到es中？</p><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">1. 安装和配置 Elasticsearch： 首先，您需要安装并配置 Elasticsearch 集群。确保集群正常运行，并根据您的需求进行适当的配置。</span><br><span class="line"></span><br><span class="line">2. 安装 Elasticsearch 客户端库： 您需要在您的应用程序中安装适用于您的编程语言的 Elasticsearch 客户端库。例如，如果您使用的是 Java，可以使用 Elasticsearch 的 Java 客户端库。</span><br><span class="line"></span><br><span class="line">3. 查询数据库： 在应用程序中，使用合适的数据库连接库连接到您的数据库，并执行相应的查询来检索数据。</span><br><span class="line"></span><br><span class="line">4. 处理查询结果： 一旦您从数据库中检索到数据，您需要对查询结果进行适当的处理，以便将其转换为适合存储在 Elasticsearch 中的格式。通常，您需要将查询结果转换为 JSON 格式。</span><br><span class="line"></span><br><span class="line">5. 连接 Elasticsearch： 使用安装的 Elasticsearch 客户端库，建立与 Elasticsearch 集群的连接。您需要提供 Elasticsearch 节点的地址和端口信息。</span><br><span class="line"></span><br><span class="line">6. 创建索引和映射： 在 Elasticsearch 中，数据是存储在索引中的。在将数据存储到 Elasticsearch 之前，您需要定义索引以及如何映射数据的结构。这有助于 Elasticsearch 正确地解释和处理您的数据。</span><br><span class="line"></span><br><span class="line">7. 将数据存储到 Elasticsearch： 使用 Elasticsearch 客户端库，将从数据库中检索的数据存储到 Elasticsearch 中。您可以使用 Elasticsearch 提供的 API，如 Index API 或 Bulk API，将数据一次性或批量地添加到索引中。</span><br><span class="line"></span><br><span class="line">8. 处理错误和异常： 在将数据存储到 Elasticsearch 过程中，可能会出现连接错误、数据格式问题等。您需要实施适当的错误处理和异常处理机制，以确保数据传输的稳定性和可靠性。</span><br><span class="line"></span><br><span class="line">9. 测试和验证： 一旦数据存储到 Elasticsearch 中，您应该进行验证以确保数据被正确地索引和存储。您可以使用 Elasticsearch 的查询功能来检索数据并验证其准确性。</span><br><span class="line"></span><br><span class="line">10. 定期同步或更新： 如果您的数据库中的数据经常变化，您可能需要定期同步或更新数据到 Elasticsearch 中，以保持数据的最新状态。</span><br></pre></td></tr></table></figure><p>为什么用es？</p><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">1. 强大的搜索和查询功能： Elasticsearch 是为全文搜索而设计的，具有强大的搜索和查询功能。它支持复杂的查询、全文搜索、模糊搜索、多字段搜索等，使用户能够轻松地检索和分析数据。</span><br><span class="line"></span><br><span class="line">2. 分布式架构： Elasticsearch 是一个分布式系统，可以横向扩展以处理大规模的数据。它允许将数据分布在多个节点上，从而提高性能和吞吐量。</span><br><span class="line"></span><br><span class="line">3. 实时性： Elasticsearch 提供了近乎实时的数据索引和搜索能力。这使得它在需要及时更新和查询数据的场景中非常有用，如日志分析、监控等。</span><br><span class="line"></span><br><span class="line">4. 多样的数据类型支持： Elasticsearch 不仅支持文本数据，还支持数字、日期、地理位置等多种数据类型的索引和查询。</span><br><span class="line"></span><br><span class="line">5. 灵活的数据建模： Elasticsearch 允许您自定义数据的索引结构和映射，以适应不同类型的数据。这种灵活性使其适用于各种不同领域的应用。</span><br><span class="line"></span><br><span class="line">6. 实时聚合和分析： Elasticsearch 提供了聚合功能，允许您在查询时计算统计数据、汇总和分析结果。这对于数据分析和可视化非常有帮助。</span><br><span class="line"></span><br><span class="line">7. 开源社区和生态系统： Elasticsearch 拥有庞大的开源社区和丰富的生态系统，提供了许多插件、工具和扩展，可以方便地集成到各种应用和技术栈中。</span><br><span class="line"></span><br><span class="line">8. 日志和事件处理： Elasticsearch 常用于处理大量日志和事件数据。它能够快速地索引、存储和分析日志，支持日志滚动、数据保留策略等。</span><br><span class="line"></span><br><span class="line">9. 全文搜索和自然语言处理： Elasticsearch 支持多语言的全文搜索和自然语言处理，使用户能够从文本数据中提取有价值的信息。</span><br><span class="line"></span><br><span class="line">10. 可视化和仪表盘： Elasticsearch 通常与 Kibana 一起使用，Kibana 是一个用于数据可视化和仪表盘构建的工具。这使得用户可以以直观的方式查看和分析数据。</span><br></pre></td></tr></table></figure><p>代码评审和需求评审都要评哪些内容？</p><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="params">###</span> 需求评审：</span><br><span class="line"></span><br><span class="line">1. 完整性和准确性： 检查需求文档是否完整，所有的需求是否被明确地列出，并且是否准确地描述了用户和系统之间的期望行为。</span><br><span class="line"></span><br><span class="line">2. 一致性和合理性： 确保需求之间没有矛盾，没有重复，而且各项需求在整体上是合理的。</span><br><span class="line"></span><br><span class="line">3. 可测性： 需求是否能够被测量和验证，以确保满足了预期的标准和条件。</span><br><span class="line"></span><br><span class="line">4. 优先级和重要性： 确定各项需求的优先级，以确保高优先级的需求能够被首先满足。</span><br><span class="line"></span><br><span class="line">5. 可行性和可实现性： 评估需求是否在技术和资源限制下是可行的，并且是否可以被实现。</span><br><span class="line"></span><br><span class="line">6. 边界情况和异常情况： 考虑边界情况和异常情况，以确保系统在不同情况下的行为都得到了考虑。</span><br><span class="line"></span><br><span class="line">7. 用户界面和用户体验： 确保用户界面的设计是否符合用户的期望和需求，以及是否易于使用。</span><br><span class="line"></span><br><span class="line">8. 业务流程和逻辑： 确保需求能够涵盖完整的业务流程，以及各项需求之间的逻辑关系是否合理。</span><br><span class="line"></span><br><span class="line">9. 可扩展性和未来需求： 考虑系统未来可能的变化和扩展，以确保需求可以适应变化的需求。</span><br><span class="line"></span><br><span class="line"><span class="params">###</span> 代码评审：</span><br><span class="line"></span><br><span class="line">1. 代码逻辑和正确性： 检查代码的逻辑是否正确，是否按照设计和需求进行了实现。</span><br><span class="line"></span><br><span class="line">2. 代码风格和规范： 确保代码符合团队的编码规范和风格指南，以提高代码的可读性和一致性。</span><br><span class="line"></span><br><span class="line">3. 错误处理和异常情况： 确保代码在各种情况下都有适当的错误处理和异常处理机制，以保证系统的稳定性和可靠性。</span><br><span class="line"></span><br><span class="line">4. 性能和效率： 检查代码是否具有良好的性能和效率，是否避免了不必要的资源浪费。</span><br><span class="line"></span><br><span class="line">5. 安全性： 确保代码没有安全漏洞，是否采取了适当的安全措施，以防止潜在的安全问题。</span><br><span class="line"></span><br><span class="line">6. 可维护性： 评估代码是否易于维护，是否有适当的注释和文档，以及是否遵循了良好的软件工程实践。</span><br><span class="line"></span><br><span class="line">7. 单元测试和集成测试： 检查代码是否有相应的单元测试和集成测试，以确保代码的正确性和稳定性。</span><br><span class="line"></span><br><span class="line">8. 重用和模块化： 确保代码具有良好的模块化，是否能够被重用，并且是否遵循了面向对象的设计原则。</span><br><span class="line"></span><br><span class="line">9. 代码依赖和第三方库： 检查代码的依赖关系和使用的第三方库，以确保它们的合法性和稳定性。</span><br><span class="line"></span><br><span class="line">10. 代码版本管理： 确保代码正确地集成到版本控制系统中，以便跟踪和管理代码的变化。</span><br></pre></td></tr></table></figure><h3 id="微服务"><a href="#微服务" class="headerlink" title="微服务"></a>微服务</h3><p>你对微服务这一块有什么了解？</p><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">微服务是一种架构风格，旨在将大型软件应用程序拆分成一组小型、独立的服务单元，每个服务单元负责执行特定的业务功能。每个微服务都是一个独立的部署单元，可以独立开发、测试、部署和扩展。微服务架构的目标是提高应用程序的可维护性、可伸缩性和灵活性。</span><br><span class="line"></span><br><span class="line">以下是微服务架构的一些关键特点和概念：</span><br><span class="line"></span><br><span class="line">1. 独立性： 每个微服务是一个独立的服务单元，有自己的数据库、业务逻辑和API。这种独立性使得服务能够被独立开发、部署和扩展。</span><br><span class="line"></span><br><span class="line">2. 解耦性： 微服务之间通过明确定义的API进行通信，它们是解耦的，一个微服务的变化不会直接影响其他微服务。</span><br><span class="line"></span><br><span class="line">3. 技术多样性： 微服务允许使用不同的技术栈和语言来实现不同的服务，这有助于选择最适合特定任务的技术。</span><br><span class="line"></span><br><span class="line">4. 独立部署： 每个微服务都可以独立部署，这使得团队可以频繁地进行部署，减少了发布的风险和复杂性。</span><br><span class="line"></span><br><span class="line">5. 可伸缩性： 由于每个微服务可以独立扩展，可以根据需求对特定的服务进行水平扩展，提高系统的整体性能。</span><br><span class="line"></span><br><span class="line">6. 灵活性和敏捷性： 微服务架构支持快速开发和迭代，因为更小的服务单元可以更快地进行开发、测试和交付。</span><br><span class="line"></span><br><span class="line">7. 容错性： 如果一个微服务失败，不会影响整个系统，因为其他微服务仍然可以正常运行。</span><br><span class="line"></span><br><span class="line">8. 数据管理： 微服务通常有自己的数据库，但也可能存在数据共享和一致性的挑战。</span><br><span class="line"></span><br><span class="line">9. 监控和管理： 由于微服务分散在不同的服务单元中，需要良好的监控和管理来跟踪整个系统的运行情况。</span><br><span class="line"></span><br><span class="line">10. 团队自治： 不同的微服务可以由不同的团队负责，提供了一定程度的自治性。</span><br><span class="line"></span><br><span class="line">11. 服务发现和治理： 在微服务架构中，服务发现和治理是重要的组成部分，以确保服务能够相互找到和通信。</span><br><span class="line"></span><br><span class="line">微服务架构适用于复杂的应用，特别是在需要快速迭代、灵活开发和部署、以及处理大量并发请求时。然而，微服务架构也带来了一些挑战，如分布式系统的复杂性、服务间通信的开销、数据一致性等问题，需要在设计和实施时加以考虑。</span><br></pre></td></tr></table></figure><p>说一下分布式的事务处理？</p><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">1. 两阶段提交（2PC）： 这是一种经典的分布式事务协调协议。它涉及两个阶段：准备阶段和提交阶段。在准备阶段，事务协调器询问各个参与者是否准备好提交，然后根据响应决定是否继续。在提交阶段，如果所有参与者都准备好，则事务协调器通知所有参与者提交事务。然而，2PC 在某些情况下可能会导致阻塞和单点故障问题。</span><br><span class="line"></span><br><span class="line">2. 三阶段提交（3PC）： 这是对2PC的改进，引入了预提交阶段。在预提交阶段，协调器询问参与者是否可以提交，但不会立即提交事务。如果所有参与者都同意，协调器进入最终提交阶段。3PC在一些情况下可以减少2PC的问题，但仍然可能存在一些限制。</span><br><span class="line"></span><br><span class="line">3. 补偿事务（Compensating Transaction）： 这种方法允许在事务失败时执行一些补偿操作，以将系统状态恢复到之前的一致状态。补偿事务适用于长时间运行的事务，它通过在错误发生时执行逆向操作来实现一致性。</span><br><span class="line"></span><br><span class="line">4. 最终一致性： 这是一种在分布式系统中处理事务一致性的较为宽松的方法。它认为在一段时间后，数据会达到一致状态，但不一定是立即的。常见的最终一致性模型包括事件溯源和分布式日志。</span><br><span class="line"></span><br><span class="line">5. 分布式事务消息： 使用消息队列来确保一致性，每个事务操作都被包装为消息，然后由消息队列来保证消息的可靠传递和处理。这种方式可以在分布式环境下实现一致性，但需要考虑消息队列的可靠性。</span><br><span class="line"></span><br><span class="line">6. Saga模式： 分布式事务被拆分成一系列局部事务，每个局部事务有一个对应的补偿操作。在分布式环境中，Saga模式适用于长时间运行的事务，通过逐步执行一系列操作来保持一致性。</span><br></pre></td></tr></table></figure><p>Spring 事务处理失败的原因？</p><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">Spring事务处理失败的原因如下：</span><br><span class="line"></span><br><span class="line">类没有被Spring托管。</span><br><span class="line">不正确的异常捕获。</span><br><span class="line">propagation事务传播行为配置错误。</span><br><span class="line">rollbackFor参数设置错误。</span><br><span class="line">Bean没有被Spring管理。</span><br><span class="line">方法没有使用public修饰。</span><br><span class="line">数据源没有开启事务管理器。</span><br><span class="line">使用了异常处理，但重新抛出的异常不是运行时异常。</span><br><span class="line">注解修饰的方法为非public时，@Transactional不会起作用。</span><br><span class="line">同一类内，调用带有@Transactional注解的方法不会生效。</span><br><span class="line">在@Transactional注解修饰的方法内使用try...catch...捕获异常，在catch内不抛出新的异常。</span><br><span class="line">使用的数据库引擎不支持事务。</span><br></pre></td></tr></table></figure><p>如何防止分布式锁发生死锁呢？</p><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">1. 超时机制： 允许锁的持有者在一段时间内持有锁，如果超过了预定的时间仍然没有释放锁，系统可以自动将其释放，以避免长时间的锁持有。这样可以防止某个节点在崩溃或出现其他问题时一直持有锁。</span><br><span class="line"></span><br><span class="line">2. 资源优先级： 为资源分配不同的优先级，当一个节点需要多个资源时，按照资源的优先级顺序来获取锁，这有助于减少死锁的可能性。</span><br><span class="line">3. 两阶段锁： 引入两阶段锁协议，其中节点首先获取所有需要的锁资源，然后才开始执行操作，最后一次性释放所有锁资源，这有助于减少死锁的可能性。</span><br><span class="line"></span><br><span class="line">4. 使用带有超时的尝试机制： 在尝试获取锁资源时，设置一个合理的超时时间，如果在超时时间内没有获取到锁，就放弃或重新尝试。</span><br><span class="line"></span><br><span class="line">5. 使用分布式事务： 在分布式系统中，可以使用分布式事务来确保多个资源的一致性，而不是仅仅依赖于锁来管理资源。</span><br></pre></td></tr></table></figure><p>Gateway中的路由表是怎么维护的？</p><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">1. ID：路由的唯一标识符，可以在配置文件中使用。如：`id: my<span class="built_in">_</span>route`。</span><br><span class="line"></span><br><span class="line">2. 目标URI：定义请求应该被转发到的目标URI或URL。如：`uri: http://example.com`。</span><br><span class="line"></span><br><span class="line">3. 谓词（Predicates）：定义何时应该将请求转发到该路由。谓词可以基于HTTP方法、路径、请求头等进行匹配。如：`predicates: - Path=/api/`。</span><br><span class="line"></span><br><span class="line">4. 过滤器（Filters）：定义在转发请求之前或之后执行的操作，如添加请求头、更改请求体等。如：`filters: - AddRequestHeader=X-Request-Foo, Bar`。</span><br></pre></td></tr></table></figure><p>Gateway是怎么做路由转发的？</p><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">1. 请求进入Gateway：当一个请求进入Gateway时，Gateway会根据配置的路由谓词逐个匹配路由配置，找到与请求匹配的路由。</span><br><span class="line"></span><br><span class="line">2. 匹配谓词：Gateway将传入请求与每个路由的谓词进行匹配。如果请求满足某个路由的谓词条件，那么该路由将被选中。</span><br><span class="line"></span><br><span class="line">3. 应用过滤器：一旦找到匹配的路由，Gateway会应用该路由定义的过滤器。过滤器可以在请求转发之前（pre）或之后（post）执行操作。</span><br><span class="line"></span><br><span class="line">4. 转发请求：一旦过滤器执行完毕，Gateway会将请求转发到路由配置中定义的目标URI或URL。这可能是另一个微服务的地址，也可以是外部服务的URL。</span><br><span class="line"></span><br><span class="line">5. 获取响应：Gateway接收目标服务的响应后，同样会经过过滤器链。过滤器可以在响应返回给客户端之前对响应进行修改或处理。</span><br></pre></td></tr></table></figure><p>Nacos是怎么做服务发现的？</p><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">1. 注册服务：当一个微服务启动时，它会向 Nacos 注册自己的信息，包括服务名称、IP 地址、端口号等。这将使 Nacos 能够知道哪些服务当前可用。</span><br><span class="line"></span><br><span class="line">2. 发现服务：其他微服务或客户端可以向 Nacos 查询特定服务的信息，比如根据服务名称获取它的 IP 地址和端口号。Nacos 会维护一个服务注册表，记录着当前注册在它上面的所有服务的信息。</span><br><span class="line"></span><br><span class="line">3. 健康检查：Nacos 会定期向已注册的微服务发送健康检查请求，以确定它们是否仍然可用。如果一个服务未能及时响应健康检查，Nacos 将会将其标记为不可用，从而避免将请求路由到不可用的服务。</span><br><span class="line"></span><br><span class="line">4. 动态感知和更新：Nacos 具有动态感知服务状态的能力。当有新的服务注册或注销时，Nacos 将自动更新其服务注册表，确保服务的状态信息始终是最新的。</span><br></pre></td></tr></table></figure><p>项目中怎么用的熔断？</p><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">1. 添加依赖：首先，在项目的构建文件（如`pom.xml`）中添加Hystrix的依赖。</span><br><span class="line"></span><br><span class="line">2. 开启熔断功能：在主应用程序类上添加`@EnableCircuitBreaker`注解，以启用Hystrix的熔断功能。</span><br><span class="line"></span><br><span class="line">3. 定义熔断逻辑：在需要进行熔断的服务调用方法上，使用`@HystrixCommand`注解来定义熔断逻辑。</span><br><span class="line"></span><br><span class="line">4. 配置熔断参数：您可以通过配置文件设置Hystrix的相关参数，例如熔断的超时时间、最小请求数等。在`application.properties`或`application.yml`中添加相关配置。</span><br></pre></td></tr></table></figure><p>fasDFS的好处是什么？</p><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">1. 高性能： FastDFS 的设计目标之一是高性能。它采用了分布式架构，可以通过将文件切分成小块，将文件存储在不同的服务器上，从而实现高吞吐量和低延迟。</span><br><span class="line"></span><br><span class="line">2. 水平扩展： FastDFS 支持水平扩展，可以通过增加服务器节点来扩展存储容量和性能，适应不断增长的数据需求。</span><br><span class="line"></span><br><span class="line">3. 负载均衡： FastDFS 自带负载均衡机制，通过 Tracker 节点来分配文件上传和下载请求到不同的存储节点，避免了单一节点负载过重的问题。</span><br><span class="line"></span><br><span class="line">4. 容易管理： FastDFS 的管理相对较简单，包括文件上传、下载、删除等操作都可以通过命令行或客户端库来完成。</span><br><span class="line"></span><br><span class="line">5. 数据冗余： FastDFS 可以配置多个副本来保障数据的冗余和高可用性，防止数据丢失。</span><br><span class="line"></span><br><span class="line">6. 适用于大文件： FastDFS 适用于存储大文件，可以将大文件切分成小块，减少传输和存储的负担。</span><br><span class="line"></span><br><span class="line">7. 适合分布式环境： FastDFS 的分布式特性使得它适用于大规模分布式环境，例如在分布式应用中存储用户上传的文件。</span><br></pre></td></tr></table></figure><p>fasDFS是怎么存储的？</p><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">1. Tracker 节点： Tracker 节点是 FastDFS 的管理节点，负责管理存储节点的状态和文件的元数据（文件路径、存储节点信息等）。客户端通过 Tracker 节点来获取可用的存储节点信息。</span><br><span class="line"></span><br><span class="line">2. Storage 节点： Storage 节点是实际存储数据的节点。每个 Storage 节点都具有独立的存储空间，并且可以配置多个存储节点来实现数据冗余。Storage 节点支持多种存储方式，如普通文件系统、内存文件系统等。</span><br><span class="line"></span><br><span class="line">3. 文件切分： FastDFS 将大文件切分成小块，每个小块通常称为一个 &quot;文件分片&quot; 或 &quot;数据块&quot;。这样的做法有助于减轻存储节点的负担，提高文件传输和存储的效率。</span><br><span class="line"></span><br><span class="line">4. 文件元数据： FastDFS 存储文件的元数据，包括文件名、文件大小、存储节点信息等。这些元数据通常由 Tracker 节点维护，用于指导客户端请求文件或上传文件。</span><br><span class="line"></span><br><span class="line">5. 文件标识： 在 FastDFS 中，文件的标识通常是由文件的 &quot;组名&quot; 和 &quot;文件名&quot; 组成。组名是用于标识一组相关文件的前缀，文件名则是具体的文件标识。</span><br><span class="line"></span><br><span class="line">存储流程如下：</span><br><span class="line"></span><br><span class="line">1. 客户端首先向 Tracker 节点发送请求，获取可用的存储节点信息。</span><br><span class="line"></span><br><span class="line">2. 客户端选择一个 Storage 节点，并将要上传的文件分片传输到该节点。</span><br><span class="line"></span><br><span class="line">3. Storage 节点接收到文件分片后，将其存储在本地文件系统或其他存储介质中。</span><br><span class="line"></span><br><span class="line">4. Tracker 节点维护文件元数据，记录文件的组名、文件名、存储节点信息等。</span><br><span class="line"></span><br><span class="line">5. 客户端可以通过文件的标识（组名 + 文件名）向 Tracker 节点请求下载文件，Tracker 节点返回存储节点信息，客户端可以直接从指定的 Storage 节点下载文件分片。</span><br></pre></td></tr></table></figure><p>怎么避免代码冲突？</p><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="params">###</span> 避免代码冲突：</span><br><span class="line"></span><br><span class="line">1. 代码分区： 将代码按模块、功能或文件进行分区，每个开发者专注于自己的分区，降低冲突的可能性。</span><br><span class="line"></span><br><span class="line">2. 频繁提交： 经常提交代码到版本控制系统，以减少多人同时修改同一文件的机会。</span><br><span class="line"></span><br><span class="line">3. 代码规范： 遵循一致的代码规范，降低不同开发者之间的冲突概率。</span><br><span class="line"></span><br><span class="line">4. 独立功能分支： 使用分支策略，在不同的分支上进行开发，只在合并到主干前进行合并和解决冲突。</span><br><span class="line"></span><br><span class="line">5. 通信和协调： 在团队中，及时沟通和协调工作，确保大家知道谁在处理哪些文件或功能。</span><br><span class="line"></span><br><span class="line"><span class="params">###</span> 解决代码冲突：</span><br><span class="line"></span><br><span class="line">1. 合并前拉取最新代码： 在开始工作前，拉取最新的代码，确保你的本地代码与远程仓库同步。</span><br><span class="line"></span><br><span class="line">2. 合并冲突： 如果合并时出现冲突，版本控制系统会提示冲突的文件。打开这些文件，手动解决冲突。</span><br><span class="line"></span><br><span class="line">3. 理解冲突原因： 仔细查看冲突的部分，了解其他开发者做了什么修改，以便做出合适的决策。</span><br><span class="line"></span><br><span class="line">4. 选择正确的更改： 根据代码的逻辑和需要，选择你的修改或其他开发者的修改，或者对两者进行合并。</span><br><span class="line"></span><br><span class="line">5. 测试解决方案： 在解决冲突后，确保修改后的代码仍然能够正确运行并通过测试。</span><br><span class="line"></span><br><span class="line">6. 重新提交： 解决冲突后，重新提交代码到版本控制系统。</span><br><span class="line"></span><br><span class="line">7. 代码审查： 如果冲突涉及多人合作，最好在解决冲突后进行代码审查，以确保冲突解决得当。</span><br><span class="line"></span><br><span class="line">8. 避免类似冲突： 在解决一个冲突后，可以考虑与其他开发者讨论如何避免类似的冲突。</span><br></pre></td></tr></table></figure><p>事务怎么用的？</p><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">事务的开启：在开始进行一组数据库操作前，你需要在代码中显式地开启一个事务。在大部分数据库系统中，可以使用类似于 BEGIN TRANSACTION 或者 START TRANSACTION 的 SQL 语句来开启一个事务。</span><br><span class="line"></span><br><span class="line">操作数据库：在事务中，你可以执行一系列的数据库操作，如插入、更新、删除等。</span><br><span class="line"></span><br><span class="line">事务的提交：如果所有操作都成功完成，你可以使用类似于 COMMIT 的 SQL 语句来提交事务。这会将所有操作应用到数据库中，并将事务标记为成功。</span><br><span class="line"></span><br><span class="line">事务的回滚：如果在事务中的任何一个操作失败，你可以使用类似于 ROLLBACK 的 SQL 语句来回滚事务。这会将事务中的所有操作撤销，将数据库恢复到事务开始之前的状态。</span><br></pre></td></tr></table></figure><p>分布式锁用过吗？</p><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">1. 基于数据库的锁：可以使用数据库的事务特性来实现分布式锁。在数据库中创建一个特定的表或记录，表示锁的状态。当某个进程要获取锁时，首先尝试插入一条记录，如果插入成功，则获取到了锁，执行任务完成后删除该记录来释放锁。</span><br><span class="line"></span><br><span class="line">2. 基于缓存的锁：利用分布式缓存（如Redis）来实现锁。通过在缓存中设置一个特定的键值对来表示锁的状态，获取锁时设置键的值为某个唯一标识，释放锁时删除这个键值对。</span><br><span class="line"></span><br><span class="line">3. 基于ZooKeeper的锁：ZooKeeper是一个分布式协调服务，可以使用它来实现分布式锁。通过在ZooKeeper的目录结构中创建临时顺序节点来表示锁的状态，每个节点代表一个进程的锁请求。进程获取锁时，检查自己的节点是否为最小的节点，如果是，则获取到了锁，完成任务后删除节点来释放锁。</span><br><span class="line"></span><br><span class="line">4. 基于分布式算法的锁：例如，通过使用分布式的算法（比如Chubby、Raft等）来实现分布式锁。这些算法通常会保证在分布式环境中实现强一致性，从而确保锁的正确性。</span><br></pre></td></tr></table></figure><p>如何防止分布式锁发生死锁呢？</p><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">1. 超时机制： 允许锁的持有者在一段时间内持有锁，如果超过了预定的时间仍然没有释放锁，系统可以自动将其释放，以避免长时间的锁持有。这样可以防止某个节点在崩溃或出现其他问题时一直持有锁。</span><br><span class="line"></span><br><span class="line">2. 资源优先级： 为资源分配不同的优先级，当一个节点需要多个资源时，按照资源的优先级顺序来获取锁，这有助于减少死锁的可能性。</span><br><span class="line">3. 两阶段锁： 引入两阶段锁协议，其中节点首先获取所有需要的锁资源，然后才开始执行操作，最后一次性释放所有锁资源，这有助于减少死锁的可能性。</span><br><span class="line"></span><br><span class="line">4. 使用带有超时的尝试机制： 在尝试获取锁资源时，设置一个合理的超时时间，如果在超时时间内没有获取到锁，就放弃或重新尝试。</span><br><span class="line"></span><br><span class="line">5. 使用分布式事务： 在分布式系统中，可以使用分布式事务来确保多个资源的一致性，而不是仅仅依赖于锁来管理资源。</span><br></pre></td></tr></table></figure><p>说一说Spring中AOP都可以干什么？</p><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">1. 日志记录： 可以使用AOP来自动记录方法的入参、返回值和执行时间，以便进行调试和性能分析。</span><br><span class="line"></span><br><span class="line">2. 安全性： AOP可以用于实现安全控制，例如在方法调用前进行权限检查，确保只有有权限的用户可以执行某些操作。</span><br><span class="line"></span><br><span class="line">3. 事务管理： 可以使用AOP来自动管理事务，确保方法在执行时按照指定的事务策略进行提交或回滚。</span><br><span class="line"></span><br><span class="line">4. 异常处理： AOP可以捕获方法执行过程中抛出的异常，并进行统一的处理，例如将异常转化为特定的错误码或日志记录。</span><br><span class="line"></span><br><span class="line">5. 性能监控： 通过AOP可以在方法调用前后记录时间戳，从而计算方法的执行时间，以进行性能监控和优化。</span><br><span class="line"></span><br><span class="line">6. 缓存管理： AOP可以用于将方法的返回值缓存起来，以便在后续相同参数调用时可以直接返回缓存的结果。</span><br><span class="line"></span><br><span class="line">7. 日志切面： 可以创建一个日志切面来自动为各个业务方法添加日志记录功能，而无需在每个方法中手动添加日志代码。</span><br><span class="line"></span><br><span class="line">8. 权限检查： 可以使用AOP在方法调用前检查用户的权限，以决定是否允许执行特定操作。</span><br><span class="line"></span><br><span class="line">9. 性能优化： AOP可以用于识别并优化应用程序中的性能瓶颈，例如识别方法调用频率高的地方。</span><br><span class="line"></span><br><span class="line">10. 跨模块通信： AOP可以在不同模块之间注入通信逻辑，从而实现模块之间的解耦和通信。</span><br></pre></td></tr></table></figure><h3 id="银行账户和支付宝"><a href="#银行账户和支付宝" class="headerlink" title="银行账户和支付宝"></a>银行账户和支付宝</h3><p>账户有几种状态？</p><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">1. 正常状态（Active）： 账户处于正常状态时，客户可以自由地进行存款、取款、转账等操作，账户余额正常可用。</span><br><span class="line">2. 冻结状态（Frozen）： 账户可能会被冻结，这通常是因为银行怀疑账户存在安全风险、欺诈活动或其他异常情况。在冻结状态下，客户通常无法执行大部分交易，直到银行解除冻结。</span><br><span class="line">3. 关闭状态（Closed）： 账户可以因多种原因被关闭，如客户要求关闭、账户余额为零、持有人去世等。在关闭状态下，通常不再允许任何交易。</span><br><span class="line">4. 挂失状态（Reported Lost/Stolen）： 如果客户的银行卡或账户信息丢失或被盗，他们可以报告挂失。在挂失状态下，与账户相关的交易可能会受到限制，以防止未经授权的访问。</span><br><span class="line">5. 呆账状态（Bad Debt）： 如果客户长期不还款或无法偿还债务，账户可能被认定为呆账。这意味着银行可能会采取进一步的行动来追回欠款，这可能包括法律途径。</span><br><span class="line">6. 透支状态（Overdrawn）： 如果账户余额低于零，即透支，账户可能会进入透支状态。银行可能会对透支账户收取费用，并要求客户迅速补足余额。</span><br><span class="line">7. 部分冻结状态（Partial Freeze）： 在某些情况下，银行可能只会冻结账户的一部分余额或特定类型的交易，而不是完全冻结账户。</span><br><span class="line">8. 等待激活状态（Pending Activation）： 在客户申请开设新账户时，账户可能需要等待激活。在这种状态下，客户通常还不能进行交易，直到账户被正式激活。</span><br><span class="line">9. 限制状态（Restricted）： 银行可以根据特定条件限制账户的某些功能，例如只允许某些类型的交易或限制交易的频率和金额。</span><br></pre></td></tr></table></figure><p>用支付宝支付采用的什么签名方式？</p><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">RSA签名</span><br><span class="line"></span><br><span class="line">1. 生成密钥对：商户在支付宝开放平台上生成一对RSA密钥，包括一个私钥和一个对应的公钥。私钥需要妥善保存，用于对交易数据进行签名，而公钥会被支付宝用来验证签名的有效性。</span><br><span class="line"></span><br><span class="line">2. 构建请求参数：当商户发起支付请求时，需要将交易相关的参数构建成一个字符串，通常是按照一定的规则拼接而成。</span><br><span class="line"></span><br><span class="line">3. 使用私钥进行签名：使用商户生成的私钥对构建的请求参数进行签名。签名的过程通常包括对请求参数进行摘要计算，然后使用私钥对摘要进行加密，生成签名字符串。</span><br><span class="line"></span><br><span class="line">4. 将签名添加到请求参数中：将生成的签名字符串添加到支付请求的参数中。</span><br><span class="line"></span><br><span class="line">5. 向支付宝发起请求：将带有签名的请求参数发送给支付宝服务器。</span><br><span class="line"></span><br><span class="line">6. 支付宝验证签名：支付宝服务器接收到请求后，会从请求参数中提取签名，并使用商户的公钥进行解密得到摘要。然后，支付宝会对请求参数进行摘要计算，将计算得到的摘要与解密得到的摘要进行比较，以验证签名的有效性。</span><br><span class="line"></span><br><span class="line">7. 处理支付结果：支付宝会对签名的有效性进行验证，如果验证通过，会处理支付请求，并返回相应的支付结果给商户。</span><br></pre></td></tr></table></figure><p>支付宝下单用的什么接口？</p><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">1. 手机网站支付接口（Wap支付）：适用于手机网站的支付接口，用户在手机浏览器上进行支付。用户点击支付按钮后，会跳转到支付宝的支付页面进行支付。</span><br><span class="line"></span><br><span class="line">2. APP支付接口：适用于移动应用，商户可以在应用内调用支付宝SDK，实现支付功能。用户可以在应用内完成支付，无需跳转到支付宝页面。</span><br><span class="line"></span><br><span class="line">3. 扫码支付接口：商户生成一个支付宝扫码支付的二维码，用户使用支付宝扫描二维码后进行支付。这种方式适用于线下门店、传统电商等场景。</span><br><span class="line"></span><br><span class="line">4. 当面付接口：适用于线下门店，商户可以使用支付宝扫码枪或移动终端，用户扫描商户生成的二维码进行支付。这种方式主要用于实体店铺。</span><br><span class="line"></span><br><span class="line">5. 电脑网站支付接口：适用于PC网站，用户在网站上进行支付。用户在网站上填写支付信息后，会跳转到支付宝页面完成支付。</span><br><span class="line"></span><br><span class="line">6. 小程序支付接口：适用于支付宝小程序，实现小程序内的支付功能。用户可以在小程序内进行支付。</span><br></pre></td></tr></table></figure><p>支付宝的二维码怎么生成的？</p><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">1. 注册并申请支付宝开放平台账号：首先，你需要在支付宝开放平台上注册一个账号，并申请成为合作伙伴。通过这个账号，你可以获取到用于调用支付宝接口的身份凭证和密钥。</span><br><span class="line"></span><br><span class="line">2. 选择适当的接口：根据你的业务场景，选择适合的支付宝支付接口，如扫码支付、当面付等。</span><br><span class="line"></span><br><span class="line">3. 构建请求参数：根据支付宝提供的接口文档，构建请求参数。这些参数通常包括商品信息、订单号、金额等。</span><br><span class="line"></span><br><span class="line">4. 调用支付宝接口：使用你的支付宝开放平台账号生成的身份凭证和密钥，通过发送HTTP请求调用支付宝的接口。这个接口会返回一个支付链接或二维码链接。</span><br><span class="line"></span><br><span class="line">5. 生成二维码：如果接口返回的是二维码链接，你可以使用各种二维码生成库或工具将链接生成为二维码图片。这个二维码图片可以供用户扫描以进行支付。</span><br><span class="line"></span><br><span class="line">6. 展示二维码：将生成的二维码图片嵌入到你的网站、应用、或者实体店铺中，供用户扫描进行支付。</span><br></pre></td></tr></table></figure><p>调用支付宝接口都有哪些必传的参数？</p><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">1. 商户订单号（out<span class="built_in">_</span>trade<span class="built_in">_</span>no）：商户生成的唯一订单号，用于标识每笔交易。</span><br><span class="line"></span><br><span class="line">2. 商品信息（subject）：交易商品的名称、标题等描述信息。</span><br><span class="line"></span><br><span class="line">3. 交易金额（total<span class="built_in">_</span>amount）：交易的金额，通常为人民币，单位为元。注意：不同的支付接口可能对金额的要求不同，例如小数点位数、金额区间等。</span><br><span class="line"></span><br><span class="line">4. 异步通知地址（notify<span class="built_in">_</span>url）：支付宝支付成功后，支付宝服务器会向该地址发送异步通知，商户用于接收交易结果。</span><br><span class="line"></span><br><span class="line">5. 商品描述（body）：商品详细描述。</span><br><span class="line"></span><br><span class="line">6. 商户身份（app<span class="built_in">_</span>id 或者 pid）：商户在支付宝开放平台注册的应用ID或合作伙伴身份标识。</span><br><span class="line"></span><br><span class="line">7. 商户私钥签名（sign）：使用商户私钥对请求参数进行签名，保证请求数据的完整性和安全性。</span><br><span class="line"></span><br><span class="line">8. 支付方式（product<span class="built_in">_</span>code）：指定支付的产品类型，如扫码支付、手机网站支付等。</span><br><span class="line"></span><br><span class="line">9. 订单有效时间（timeout<span class="built_in">_</span>express）：订单过期时间，一般为分钟数。</span><br><span class="line"></span><br><span class="line">10. 支付宝用户唯一标识（buyer<span class="built_in">_</span>id 或者 seller<span class="built_in">_</span>id）：如果需要绑定支付宝账户，则传入对应的支付宝用户唯一标识。</span><br></pre></td></tr></table></figure><p>调用支付宝时怎么保证不会多次调用？</p><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">1. 生成唯一订单号： 在每次发起支付请求时，生成一个唯一的订单号。这个订单号应该能够唯一标识每一笔支付请求。避免使用相同的订单号，以防止多次支付。</span><br><span class="line"></span><br><span class="line">2. 记录已支付状态： 在你的系统中，维护一个记录，标记已经成功支付的订单。在每次支付请求之前，检查该订单是否已经被成功支付，如果是，则避免重复支付。</span><br><span class="line"></span><br><span class="line">3. 加锁机制： 使用互斥锁或分布式锁来确保同一订单在同一时间只能被一个线程或进程处理。这可以防止多个并发请求同时处理同一个订单。</span><br><span class="line"></span><br><span class="line">4. 支付回调验证： 支付宝会在支付完成后通过回调通知你的系统。在接收到支付回调通知时，进行验证确保该回调是有效的，并且订单状态尚未被更新为已支付。</span><br><span class="line"></span><br><span class="line">5. 幂等性设计： 在你的系统中，所有支付接口调用都应该是幂等的，即使同一请求被多次调用，也不会产生不同的结果。这可以通过设计确保多次相同请求不会产生额外影响。</span><br><span class="line"></span><br><span class="line">6. 设置超时时间： 在支付请求中设置适当的超时时间。如果在超时时间内未收到支付结果，可以认为支付失败，避免在网络问题等情况下出现重复支付。</span><br></pre></td></tr></table></figure><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>Jdk1.8的特性？</p><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">1. Lambda 表达式：Lambda 表达式引入了函数式编程的概念，允许以更简洁的语法编写匿名函数。它可以在集合操作、线程处理等方面提供更简单、更易读的代码。</span><br><span class="line"></span><br><span class="line">2. Stream API：Stream API 提供了一种更简洁的方式来进行集合操作，包括过滤、映射、归约等。它可以帮助开发者编写更具表现力的数据处理代码。</span><br><span class="line"></span><br><span class="line">3. 新的日期和时间 API：Java 8 引入了 `java.time` 包，提供了全新的日期和时间 API，解决了旧的 `Date` 和 `Calendar` 类库中存在的一些问题，使日期和时间操作更简便和易读。</span><br><span class="line"></span><br><span class="line">4. 接口的默认方法和静态方法：在接口中可以定义默认方法（带有默认实现）和静态方法。这使得在接口中添加新方法时，不会破坏实现这个接口的类的现有代码。</span><br><span class="line"></span><br><span class="line">5. 函数式接口和注解：为了支持 Lambda 表达式，Java 8 引入了一些新的函数式接口，如 `java.util.function` 包下的接口，如 `Predicate`、`Function`、`Consumer` 等。同时，也引入了新的注解 `@FunctionalInterface`，用于标记函数式接口。</span><br><span class="line"></span><br><span class="line">6. Optional 类：`Optional` 类是一个容器对象，可以包含 null 或非 null 值。它可以帮助防止空指针异常，以更好地处理可能为 null 的值。</span><br><span class="line"></span><br><span class="line">7. 新的 Nashorn JavaScript 引擎：Java 8 引入了新的 Nashorn JavaScript 引擎，提供了更高性能的 JavaScript 执行。</span><br><span class="line"></span><br><span class="line">8. 方法引用：方法引用是一种更简洁地调用已经存在的方法的方式，它可以使代码更具可读性。</span><br><span class="line"></span><br><span class="line">9. 默认的编译器和运行时：Java 8 引入了默认的编译器（`javac`）和运行时（`java`）版本，使得编译和运行代码变得更方便。</span><br></pre></td></tr></table></figure><p>执行计划是哪个关键字？</p><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">EXPLAIN</span><br></pre></td></tr></table></figure><p>说一下jvm？</p><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">我原来学java的时候知道JVM内存结构主要有三大块：堆内存、方法区和栈。堆内存是JVM中最大的一块内存地址,它主要由年轻代和老年代还有持久代组成,所有new出来的对象都存储在该区域. 栈就是暂存数据的地方,每个线程包含一个栈区，栈存放在一级缓存中，存取速度较快,栈中只保存基础数据类型的对象和自定义对象的引用.每个栈中的数据都是私有的，其他栈不能访问。方法区存放了要加载的类的信息（如类名、修饰符等）、静态变量、构造函数、final定义的常量、类中的字段和方法等信息。</span><br></pre></td></tr></table></figure><p>项目启动需要设置一些基本的jvm参数，分别是哪些？</p><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">1. 内存相关参数：</span><br><span class="line">   - `-Xms`: 初始堆内存大小，指定JVM启动时分配的堆内存大小。</span><br><span class="line">   - `-Xmx`: 最大堆内存大小，指定JVM可以使用的最大堆内存大小。</span><br><span class="line">   - `-Xss`: 设置每个线程的栈大小。</span><br><span class="line"></span><br><span class="line">2. 垃圾回收相关参数：</span><br><span class="line">   - `-XX:+UseG1GC`: 使用G1垃圾收集器。</span><br><span class="line">   - `-XX:+UseParallelGC`: 使用并行垃圾收集器。</span><br><span class="line">   - `-XX:+UseConcMarkSweepGC`: 使用CMS垃圾收集器。</span><br><span class="line">   - `-XX:+UseSerialGC`: 使用串行垃圾收集器。</span><br><span class="line">   - `-XX:NewRatio`: 设置年轻代和老年代的比例。</span><br><span class="line">   - `-XX:MaxMetaspaceSize`: 最大Metaspace（永久代的替代）大小。</span><br><span class="line"></span><br><span class="line">3. 性能优化参数：</span><br><span class="line">   - `-XX:+OptimizeStringConcat`: 启用字符串拼接优化。</span><br><span class="line">   - `-XX:+AggressiveOpts`: 启用一些常见的性能优化。</span><br><span class="line">   - `-XX:+UseBiasedLocking`: 启用偏向锁优化。</span><br><span class="line">   - `-XX:+UseFastAccessorMethods`: 启用快速访问器方法。</span><br><span class="line"></span><br><span class="line">4. 应用程序参数：</span><br><span class="line">   - `-DpropertyName=value`: 设置系统属性，可以在应用程序中通过`System.getProperty(&quot;propertyName&quot;)`获取。</span><br><span class="line">   - `-Dspring.profiles.active=profileName`: 设置Spring的活动配置文件。</span><br><span class="line"></span><br><span class="line">5. 调试和监控参数：</span><br><span class="line">   - `-Xdebug`: 启用调试模式。</span><br><span class="line">   - `-Xrunjdwp:transport=dt<span class="built_in">_</span>socket,address=port,server=y,suspend=n`: 启用远程调试。</span><br><span class="line">   - `-XX:+HeapDumpOnOutOfMemoryError`: 在内存溢出时生成堆转储文件。</span><br></pre></td></tr></table></figure><p>Java中常用的设计模式？</p><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">创建型模式（Creational Patterns）：</span><br><span class="line">   - 工厂方法模式（Factory Method Pattern）</span><br><span class="line">   - 抽象工厂模式（Abstract Factory Pattern）</span><br><span class="line">   - 单例模式（Singleton Pattern）</span><br><span class="line">   - 建造者模式（Builder Pattern）</span><br><span class="line">   - 原型模式（Prototype Pattern）</span><br></pre></td></tr></table></figure><p>Spring中的bean怎么保证线程安全？</p><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">1. 使用原型作用域： Spring中的Bean可以有不同的作用域，包括单例（Singleton）和原型（Prototype）等。如果你需要确保多线程环境下的线程安全性，可以考虑将Bean的作用域设置为原型，这样每次获取Bean都会创建一个新的实例，避免了多线程共享同一个实例的问题。</span><br><span class="line"></span><br><span class="line">2. 避免共享状态： 在单例模式下，如果多个线程共享同一个Bean实例，确保Bean的状态不会被多线程修改，可以使用不可变对象或者在修改状态时进行同步控制。</span><br><span class="line"></span><br><span class="line">3. 使用局部变量： 如果在方法内部创建Bean的实例并将其用作局部变量，通常不会涉及线程安全问题，因为每个线程都有自己的局部变量副本。</span><br><span class="line"></span><br><span class="line">4. 使用线程安全的类： Spring本身并不能保证Bean的线程安全性，但你可以在Bean内部使用线程安全的类和数据结构，如`ConcurrentHashMap`、`AtomicInteger`等，以确保多线程操作时的安全性。</span><br></pre></td></tr></table></figure><h3 id="数据库和事务"><a href="#数据库和事务" class="headerlink" title="数据库和事务"></a>数据库和事务</h3><p>事务有几大隔离级别？</p><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">1. READ UNCOMMITTED（读未提交）： 这是最低的隔离级别。在该级别下，一个事务可以读取其他事务尚未提交的数据，可能会导致脏读、不可重复读和幻读问题。</span><br><span class="line"></span><br><span class="line">2. READ COMMITTED（读已提交）： 在这个隔离级别下，一个事务只能读取已经提交的数据，解决了脏读问题。但仍然可能出现不可重复读和幻读问题。</span><br><span class="line"></span><br><span class="line">3. REPEATABLE READ（可重复读）： 在这个隔离级别下，一个事务在执行期间看到的数据是一致的，不受其他事务的影响。这样可以防止脏读和不可重复读问题，但可能会有幻读问题。</span><br><span class="line"></span><br><span class="line">4. SERIALIZABLE（串行化）： 这是最高的隔离级别，要求事务串行执行，完全消除了脏读、不可重复读和幻读问题。但由于事务串行执行，可能会影响并发性能。</span><br></pre></td></tr></table></figure><p>为什么会产生脏读这个现象？</p><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">在READ UNCOMMITTED级别下，一个事务可以读取其他事务尚未提交的数据。如果一个事务读取了另一个事务中的数据，而后者在事务完成前回滚，读取的数据可能是不准确的或不一致的。</span><br></pre></td></tr></table></figure><p>如何确定某个sql语句需要加索引？</p><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">1. 查询频率高： 如果某个查询在应用中频繁执行，那么为相关的列添加索引可能会显著提升查询性能。</span><br><span class="line"></span><br><span class="line">2. 连接操作： 当涉及到连接操作（例如JOIN）时，连接的列通常应该添加索引，以加速连接过程。</span><br><span class="line"></span><br><span class="line">3. WHERE 子句： 那些在 WHERE 子句中经常出现的列，特别是用于过滤和筛选数据的列，通常应该添加索引。</span><br><span class="line"></span><br><span class="line">4. 排序和分组： 需要进行排序（ORDER BY）或分组（GROUP BY）操作的列通常也应该添加索引，以加速这些操作。</span><br><span class="line"></span><br><span class="line">5. 唯一性约束： 需要保持唯一性的列（如主键、唯一索引列）必须添加索引。</span><br><span class="line"></span><br><span class="line">6. 复合索引： 对于多个列的组合查询，可以考虑使用复合索引，以便支持这些列的联合查询条件。</span><br></pre></td></tr></table></figure><p>怎么排查sql语句有没有走索引？</p><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">1. 使用 EXPLAIN 或执行计划命令：</span><br><span class="line">   - 对于大多数关系型数据库，可以使用 `EXPLAIN` 或类似的命令来获取查询的执行计划。例如，MySQL 使用 `EXPLAIN` 命令，Oracle 使用 `EXPLAIN PLAN` 命令。</span><br><span class="line">   - 运行这些命令并附加你的查询语句，数据库会返回一个详细的执行计划，展示了查询是如何被执行的，包括是否使用了索引。</span><br><span class="line"></span><br><span class="line">2. 使用数据库客户端工具：</span><br><span class="line">   - 许多数据库客户端工具（如SQL Server Management Studio、MySQL Workbench、pgAdmin等）都提供了查询执行计划的可视化界面。你可以在工具中运行查询并查看执行计划。</span><br><span class="line">   - 执行计划界面会显示查询的执行步骤，包括是否使用了索引、是否进行了表扫描等。</span><br><span class="line"></span><br><span class="line">3. 观察索引选择：</span><br><span class="line">   - 查询执行计划会显示数据库是否使用了索引，以及具体使用了哪些索引。</span><br><span class="line">   - 如果查询计划中显示索引被使用，通常会显示使用的索引名称。</span><br><span class="line"></span><br><span class="line">4. 检查执行时间和资源消耗：</span><br><span class="line">   - 如果查询没有走索引，通常会导致查询执行时间较长或者消耗较多的系统资源。</span><br><span class="line">   - 观察查询的执行时间以及占用的 CPU、内存等资源，这些可能是查询未走索引的迹象。</span><br><span class="line"></span><br><span class="line">5. 使用性能分析工具：</span><br><span class="line">   - 一些数据库性能分析工具可以帮助你更详细地分析查询执行过程，包括是否使用了索引以及可能的性能瓶颈。</span><br></pre></td></tr></table></figure><p>MySQL 和 Oracle 区别？</p><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">Mysql 相比 Oracle 更简单更轻量,在开发中 mysql 用的更多一些。但是 Oracle 的一些基本</span><br><span class="line">点也都知道，Oracle 的分页和 mysql 不一样，用的是伪列，mysql 用的是 limit。Mysql 主键可以设置自增，Oracle中并没有主键自增。</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Spring Boot 学习笔记</title>
      <link href="/2023/09/04/Spring-Boot-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2023/09/04/Spring-Boot-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>常用 Git 命令清单</title>
      <link href="/2023/09/04/%E5%B8%B8%E7%94%A8-Git-%E5%91%BD%E4%BB%A4%E6%B8%85%E5%8D%95/"/>
      <url>/2023/09/04/%E5%B8%B8%E7%94%A8-Git-%E5%91%BD%E4%BB%A4%E6%B8%85%E5%8D%95/</url>
      
        <content type="html"><![CDATA[<div class="note info simple"><ul><li>Git是程序员必备技能。本文专门记录常用的Git命令，以便日后查看。</li><li>参考声明：本文参考<a href="https://www.ruanyifeng.com/blog/2015/12/git-cheat-sheet.html">阮一峰</a>大神的网络日志。</li></ul></div><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><strong>新建Git仓库，cd到你的本地项目根目录下</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git init </span><br></pre></td></tr></table></figure><p><strong>将项目下的文件添加到仓库中</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git add .</span><br></pre></td></tr></table></figure><p><strong>提交文件到本地仓库</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git commit -m <span class="string">&quot;注释语句&quot;</span></span><br></pre></td></tr></table></figure><p><strong>拉取远程仓库到本地</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git pull origin master</span><br></pre></td></tr></table></figure><p><strong>把代码传到github远程仓库</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure><h2 id="一、新建代码库"><a href="#一、新建代码库" class="headerlink" title="一、新建代码库"></a>一、新建代码库</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 在当前目录新建一个Git代码库</span></span><br><span class="line">$ git init</span><br><span class="line"></span><br><span class="line"><span class="comment"># 新建一个目录，将其初始化为Git代码库</span></span><br><span class="line">$ git init [project-name]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 下载一个项目和它的整个代码历史</span></span><br><span class="line">$ git <span class="built_in">clone</span> [url]</span><br></pre></td></tr></table></figure><h2 id="二、配置"><a href="#二、配置" class="headerlink" title="二、配置"></a>二、配置</h2><p>Git的设置文件为<code>.gitconfig</code>，它可以在用户主目录下（全局配置），也可以在项目目录下（项目配置）。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 显示当前的Git配置</span></span><br><span class="line">$ git config --list</span><br><span class="line"></span><br><span class="line"><span class="comment"># 编辑Git配置文件</span></span><br><span class="line">$ git config -e [--global]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置提交代码时的用户信息</span></span><br><span class="line">$ git config [--global] user.name <span class="string">&quot;[name]&quot;</span></span><br><span class="line">$ git config [--global] user.email <span class="string">&quot;[email address]&quot;</span></span><br></pre></td></tr></table></figure><h2 id="三、增加-删除文件"><a href="#三、增加-删除文件" class="headerlink" title="三、增加&#x2F;删除文件"></a>三、增加&#x2F;删除文件</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 添加指定文件到暂存区</span></span><br><span class="line">$ git add [file1] [file2] ...</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加指定目录到暂存区，包括子目录</span></span><br><span class="line">$ git add [<span class="built_in">dir</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加当前目录的所有文件到暂存区</span></span><br><span class="line">$ git add .</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加每个变化前，都会要求确认</span></span><br><span class="line"><span class="comment"># 对于同一个文件的多处变化，可以实现分次提交</span></span><br><span class="line">$ git add -p</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除工作区文件，并且将这次删除放入暂存区</span></span><br><span class="line">$ git <span class="built_in">rm</span> [file1] [file2] ...</span><br><span class="line"></span><br><span class="line"><span class="comment"># 停止追踪指定文件，但该文件会保留在工作区</span></span><br><span class="line">$ git <span class="built_in">rm</span> --cached [file]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 改名文件，并且将这个改名放入暂存区</span></span><br><span class="line">$ git <span class="built_in">mv</span> [file-original] [file-renamed]</span><br></pre></td></tr></table></figure><h2 id="四、代码提交"><a href="#四、代码提交" class="headerlink" title="四、代码提交"></a>四、代码提交</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 提交暂存区到仓库区</span></span><br><span class="line">$ git commit -m [message]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 提交暂存区的指定文件到仓库区</span></span><br><span class="line">$ git commit [file1] [file2] ... -m [message]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 提交工作区自上次commit之后的变化，直接到仓库区</span></span><br><span class="line">$ git commit -a</span><br><span class="line"></span><br><span class="line"><span class="comment"># 提交时显示所有diff信息</span></span><br><span class="line">$ git commit -v</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用一次新的commit，替代上一次提交</span></span><br><span class="line"><span class="comment"># 如果代码没有任何新变化，则用来改写上一次commit的提交信息</span></span><br><span class="line">$ git commit --amend -m [message]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重做上一次commit，并包括指定文件的新变化</span></span><br><span class="line">$ git commit --amend [file1] [file2] ...</span><br></pre></td></tr></table></figure><h2 id="五、分支"><a href="#五、分支" class="headerlink" title="五、分支"></a>五、分支</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 列出所有本地分支</span></span><br><span class="line">$ git branch</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列出所有远程分支</span></span><br><span class="line">$ git branch -r</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列出所有本地分支和远程分支</span></span><br><span class="line">$ git branch -a</span><br><span class="line"></span><br><span class="line"><span class="comment"># 新建一个分支，但依然停留在当前分支</span></span><br><span class="line">$ git branch [branch-name]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 新建一个分支，并切换到该分支</span></span><br><span class="line">$ git checkout -b [branch]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 新建一个分支，指向指定commit</span></span><br><span class="line">$ git branch [branch] [commit]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 新建一个分支，与指定的远程分支建立追踪关系</span></span><br><span class="line">$ git branch --track [branch] [remote-branch]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 切换到指定分支，并更新工作区</span></span><br><span class="line">$ git checkout [branch-name]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 切换到上一个分支</span></span><br><span class="line">$ git checkout -</span><br><span class="line"></span><br><span class="line"><span class="comment"># 建立追踪关系，在现有分支与指定的远程分支之间</span></span><br><span class="line">$ git branch --set-upstream [branch] [remote-branch]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 合并指定分支到当前分支</span></span><br><span class="line">$ git merge [branch]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 选择一个commit，合并进当前分支</span></span><br><span class="line">$ git cherry-pick [commit]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除分支</span></span><br><span class="line">$ git branch -d [branch-name]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除远程分支</span></span><br><span class="line">$ git push origin --delete [branch-name]</span><br><span class="line">$ git branch -dr [remote/branch]</span><br></pre></td></tr></table></figure><h2 id="六、标签"><a href="#六、标签" class="headerlink" title="六、标签"></a>六、标签</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 列出所有tag</span></span><br><span class="line">$ git tag</span><br><span class="line"></span><br><span class="line"><span class="comment"># 新建一个tag在当前commit</span></span><br><span class="line">$ git tag [tag]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 新建一个tag在指定commit</span></span><br><span class="line">$ git tag [tag] [commit]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除本地tag</span></span><br><span class="line">$ git tag -d [tag]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除远程tag</span></span><br><span class="line">$ git push origin :refs/tags/[tagName]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看tag信息</span></span><br><span class="line">$ git show [tag]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 提交指定tag</span></span><br><span class="line">$ git push [remote] [tag]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 提交所有tag</span></span><br><span class="line">$ git push [remote] --tags</span><br><span class="line"></span><br><span class="line"><span class="comment"># 新建一个分支，指向某个tag</span></span><br><span class="line">$ git checkout -b [branch] [tag]</span><br></pre></td></tr></table></figure><h2 id="七、查看信息"><a href="#七、查看信息" class="headerlink" title="七、查看信息"></a>七、查看信息</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 显示有变更的文件</span></span><br><span class="line">$ git status</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示当前分支的版本历史</span></span><br><span class="line">$ git <span class="built_in">log</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示commit历史，以及每次commit发生变更的文件</span></span><br><span class="line">$ git <span class="built_in">log</span> --<span class="built_in">stat</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 搜索提交历史，根据关键词</span></span><br><span class="line">$ git <span class="built_in">log</span> -S [keyword]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示某个commit之后的所有变动，每个commit占据一行</span></span><br><span class="line">$ git <span class="built_in">log</span> [tag] HEAD --pretty=format:%s</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示某个commit之后的所有变动，其&quot;提交说明&quot;必须符合搜索条件</span></span><br><span class="line">$ git <span class="built_in">log</span> [tag] HEAD --grep feature</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示某个文件的版本历史，包括文件改名</span></span><br><span class="line">$ git <span class="built_in">log</span> --follow [file]</span><br><span class="line">$ git whatchanged [file]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示指定文件相关的每一次diff</span></span><br><span class="line">$ git <span class="built_in">log</span> -p [file]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示过去5次提交</span></span><br><span class="line">$ git <span class="built_in">log</span> -5 --pretty --oneline</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示所有提交过的用户，按提交次数排序</span></span><br><span class="line">$ git shortlog -sn</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示指定文件是什么人在什么时间修改过</span></span><br><span class="line">$ git blame [file]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示暂存区和工作区的差异</span></span><br><span class="line">$ git diff</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示暂存区和上一个commit的差异</span></span><br><span class="line">$ git diff --cached [file]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示工作区与当前分支最新commit之间的差异</span></span><br><span class="line">$ git diff HEAD</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示两次提交之间的差异</span></span><br><span class="line">$ git diff [first-branch]...[second-branch]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示今天你写了多少行代码</span></span><br><span class="line">$ git diff --shortstat <span class="string">&quot;@&#123;0 day ago&#125;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示某次提交的元数据和内容变化</span></span><br><span class="line">$ git show [commit]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示某次提交发生变化的文件</span></span><br><span class="line">$ git show --name-only [commit]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示某次提交时，某个文件的内容</span></span><br><span class="line">$ git show [commit]:[filename]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示当前分支的最近几次提交</span></span><br><span class="line">$ git reflog</span><br></pre></td></tr></table></figure><h2 id="八、远程同步"><a href="#八、远程同步" class="headerlink" title="八、远程同步"></a>八、远程同步</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 下载远程仓库的所有变动</span></span><br><span class="line">$ git fetch [remote]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示所有远程仓库</span></span><br><span class="line">$ git remote -v</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示某个远程仓库的信息</span></span><br><span class="line">$ git remote show [remote]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 增加一个新的远程仓库，并命名</span></span><br><span class="line">$ git remote add [shortname] [url]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 取回远程仓库的变化，并与本地分支合并</span></span><br><span class="line">$ git pull [remote] [branch]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 上传本地指定分支到远程仓库</span></span><br><span class="line">$ git push [remote] [branch]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 强行推送当前分支到远程仓库，即使有冲突</span></span><br><span class="line">$ git push [remote] --force</span><br><span class="line"></span><br><span class="line"><span class="comment"># 推送所有分支到远程仓库</span></span><br><span class="line">$ git push [remote] --all</span><br></pre></td></tr></table></figure><h2 id="九、撤销"><a href="#九、撤销" class="headerlink" title="九、撤销"></a>九、撤销</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 恢复暂存区的指定文件到工作区</span></span><br><span class="line">$ git checkout [file]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 恢复某个commit的指定文件到暂存区和工作区</span></span><br><span class="line">$ git checkout [commit] [file]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 恢复暂存区的所有文件到工作区</span></span><br><span class="line">$ git checkout .</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变</span></span><br><span class="line">$ git reset [file]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重置暂存区与工作区，与上一次commit保持一致</span></span><br><span class="line">$ git reset --hard</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变</span></span><br><span class="line">$ git reset [commit]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致</span></span><br><span class="line">$ git reset --hard [commit]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重置当前HEAD为指定commit，但保持暂存区和工作区不变</span></span><br><span class="line">$ git reset --keep [commit]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 新建一个commit，用来撤销指定commit</span></span><br><span class="line"><span class="comment"># 后者的所有变化都将被前者抵消，并且应用到当前分支</span></span><br><span class="line">$ git revert [commit]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 暂时将未提交的变化移除，稍后再移入</span></span><br><span class="line">$ git stash</span><br><span class="line">$ git stash pop</span><br></pre></td></tr></table></figure><h2 id="十、其他"><a href="#十、其他" class="headerlink" title="十、其他"></a>十、其他</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 生成一个可供发布的压缩包</span></span><br><span class="line">$ git archive</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2023/09/04/hello-world/"/>
      <url>/2023/09/04/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
